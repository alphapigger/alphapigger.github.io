---
title: 聊一聊goroutine stack
tags:
  - go
  - goroutine
  - stack
categories:
  - go
abbrlink: 2d571d09
date: 2017-07-29 17:48:51
---

> 推送在外卖订餐中扮演着重要的角色，为商家实时接单、骑手实时派单提供基础的数据通道。早期推送是由第三方服务商提供
的，随着业务复杂度的提升、订单量和用户数的持续增长，之前的系统已经远远不能满足需求，构建一个高性能、高可用的推送系统
势在必行。上半年我们用go开发了一个hybrid push服务，用户在线通过长连接下发消息，不在线借助厂商或第三方下发消息，在
构建过程中遇到了些与routine stack相关的问题，这里就和大家扯一扯。

带着问题阅读，才能让阅读更加高效，首先让我们看下问题:

1. *goroutine stack多大呢？是固定的还是动态变化的呢?*
2. *stack动态变化的话，什么时候扩容和缩容呢?*
3. *扩容和缩容是如何实现的呢? 对服务有什么影响吗?*

问题明确了，我们就开始往下扯呗。

## 栈大小

为了能够更清楚地描述goroutine stack的大小，我们先看下Linux进程内存布局:

![](/images/linux-process-memory-layout.png)

user stack的大小是固定的，Linux中默认为8192KB，运行时内存占用超过上限程序会崩溃掉并报告segment错误。
为了修复这个问题，我们可以增大内核参数中的stack size, 或者在创建线程时显式地传入所需要大小的内存块。 这两种方案
都有自己的优缺点, 前者比较简单但会影响到系统内所有的thread，后者需要开发者精确计算每个thread的大小负担比较高。

有没有办法既不影响所有thread又不会给开发者增加太多的负担呢? 答案当然是有的，比如: 我们可以在函数调用处插桩，每次调用的时候检查
当前栈的空间是否能够满足新函数的执行，满足的话直接执行，否则创建新的栈空间并将老的栈拷贝到新的栈然后再执行。 这个想法听起来很fancy & simple, 但
当前的linux thread model却不能满足，实现的话只能在用户空间且有不小的难度。

go作为一门21世纪的现代语言，定位于简单高效，自然不能够少了这个特性，它使用内置的运行时runtime优雅地解决了这个问题，每个routine在初始化
时stack大小都为2KB, 在运行过程中会根据不同的场景做动态的调整。

## 栈扩容和缩容

go在1.3之前栈是分段栈(Segmented Stack), 栈空间不够用的时候申请一块新的空间用于被调函数的执行，执行后销毁新申请的空间并返回到老的栈空间继续执行，
在函数频繁调用的时候可能会引发hot split问题；为了避免这个问题，1.3之后栈的管理改为了连续栈(Contiguous Stack), 在栈不够用的时候申请一个2X大小的
新栈，并把数据拷贝过去并替换到新栈, 接下来所有的执行都发生在新栈上。

下面我们通过一个简单的函数调用，来观察下栈的情况。

```go
```
