---
title: 聊一聊goroutine stack
tags:
  - go
  - goroutine
  - stack
categories:
  - go
abbrlink: 2d571d09
date: 2017-07-29 17:48:51
---

> 推送在外卖订餐中扮演着重要的角色，为商家实时接单、骑手实时派单提供基础的数据通道。早期推送是由第三方服务商提供
的，随着业务复杂度的提升、订单量和用户数的持续增长，之前的系统已经远远不能满足需求，构建一个高性能、高可用的推送系统
势在必行。上半年我们用`go`开发了一个`hybrid push`服务，用户在线通过长连接下发消息，不在线借助厂商或第三方下发消息，在
构建过程中遇到了些与`routine stack`相关的问题，这里就和大家扯一扯。

带着问题阅读，才能让阅读更加高效，首先让我们看下问题:

1. *goroutine stack多大呢？是固定的还是动态变化的呢?*
2. *stack动态变化的话，什么时候扩容和缩容呢?*
3. *扩容和缩容是如何实现的呢? 对服务有什么影响吗?*

问题明确了，我们就开始往下扯呗。

## 栈大小

为了能够更清楚地描述goroutine stack的大小，我们先看下Linux进程内存布局:

![](/images/linux-process-memory-layout.png)

`user stack`的大小是固定的，linux中默认为8192KB，运行时内存占用超过上限程序会崩溃掉并报告`segment`错误。
为了修复这个问题，我们可以增大内核参数中的`stack size`, 或者在创建线程时显式地传入所需要大小的内存块。 这两种方案
都有自己的优缺点, 前者比较简单但会影响到系统内所有的thread，后者需要开发者精确计算每个thread的大小负担比较高。

有没有办法既不影响所有thread又不会给开发者增加太多的负担呢? 答案当然是有的，比如: 我们可以在函数调用处插桩，每次调用的时候检查
当前栈的空间是否能够满足新函数的执行，满足的话直接执行，否则创建新的栈空间并将老的栈拷贝到新的栈然后再执行。 这个想法听起来很fancy & simple, 但
当前的linux thread model却不能满足，实现的话只能在用户空间且有不小的难度。

go作为一门21世纪的现代语言，定位于简单高效，自然不能够少了这个特性，它使用内置的运行时`runtime`优雅地解决了这个问题，每个`routine`在初始化
时stack大小都为2KB, 在运行过程中会根据不同的场景做动态的调整。

## 栈扩容和缩容
